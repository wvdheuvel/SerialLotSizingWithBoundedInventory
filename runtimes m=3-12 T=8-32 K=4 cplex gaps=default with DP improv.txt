T T 8 8 8 8 16 16 16 16 32 32 32 32 
alg alg MIP MIP DP DP DS MIP MIP DP DP DS MIP MIP DP DP DS 
m L avg std avg std DS avg std avg std DS avg std avg std DS 
3 2 0.1467 0.0726729 0.0024 0.000516398 4 0.1853 0.0623058 0.0489 0.00228279 7 0.3256 0.0468572 1.2821 0.0385413 10 
6 3 0.1639 0.0563293 0.0049 0.00228279 5 0.382 0.0856453 0.0692 0.00892935 7 3.6856 0.488782 1.7029 0.0411621 10 
6 5 0.1522 0.0839442 0.0034 0.00183787 5 0.3291 0.122111 0.0669 0.00768042 9 2.5362 0.900844 1.7226 0.0255873 9 
12 4 0.2646 0.0982776 0.0075 0.00324037 1 2.2931 1.41959 0.0932 0.0124079 5 445.797 496.904 2.3604 0.0357684 6 
12 7 0.1637 0.0551323 0.0047 0.00105935 4 1.6196 1.35044 0.0908 0.0103795 6 963.92 1586.04 2.5567 0.102098 8 
12 10 0.1684 0.0406617 0.0051 0.002079 8 0.5697 0.205675 0.0906 0.00877116 9 1544.41 2423.12 2.7557 0.131196 9 

{	int i,j;
	double baseK=4.0;

	// demand
	for (j=0; j<n; j++)
	{	d[j]=ran.IRandom(1,20);
	}	

	// cost parameters
	for (i=0; i<m; i++)
	{	for (j=0; j<n; j++)
		{	
			// setup cost
			//K[i][j]=2.0;
			if (i==L)
				K[i][j]=baseK;			
			//else if (i<L)
			//	K[i][j]=0.0;			
			else
			{	//K[i][j]=1+2*ran.Random();
				K[i][j]=round(2*baseK*ran.Random(),2);
			}
			//K[1][1]=100.0;
			//K[2][1]=100.0;

			// production cost
			if (i<=L)
			{	p[i][j]=1.0;
				//p[i][j]=0.0;
			}
			else
			{	//p[i][j]=round(ran.Random(),2);
				p[i][j]=1.0;
			}
			
			// holding cost
			//h[i][j]=1.0;
			//h[i][j]=1.0*(i+1)/m;
			//h[i][j]=1.0*pow(i+1,2.0)/pow(m,2.0);
			//h[i][j]=0.01+1.0*pow(i,2.0)/pow(m-1,2.0);
			if (i<=L)
				h[i][j]=0.01*(i+1);
			else
				h[i][j]=1.0*(i-L)/(m-L-1);
		}
	}

	// bottleneck cap
	U=10.0;
	//U=n*20.0;
}
