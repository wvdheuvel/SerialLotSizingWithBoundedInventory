T T 8 8 8 8 16 16 16 16 32 32 32 32 
alg alg MIP MIP DP DP DS MIP MIP DP DP DS MIP MIP DP DP DS 
m L avg std avg std DS avg std avg std DS avg std avg std DS 
3 2 0.1943 0.0576928 0.0038 0.00198886 3 0.2619 0.0822198 0.0539 0.00417532 8 0.365 0.0340033 1.3251 0.0451625 10 
6 3 0.1696 0.0427582 0.0037 0.000823273 3 0.3818 0.075626 0.0779 0.0116947 7 3.9275 0.412782 1.7632 0.0509113 8 
6 5 0.1556 0.0759111 0.0037 0.000948683 6 0.277 0.0583571 0.069 0.00820569 9 2.5737 0.948292 1.8195 0.112703 10 
12 4 0.2085 0.0567259 0.006 0.00290593 1 1.9417 1.23669 0.0906 0.0107311 4 356.113 318.726 2.4167 0.104022 6 
12 7 0.1676 0.0510429 0.006 0.00244949 4 0.9616 0.70277 0.0871 0.00428045 3 528.803 817.294 2.6423 0.109776 6 
12 10 0.1752 0.0504971 0.0057 0.00258414 7 0.6866 0.541721 0.0883 0.00817924 7 172.079 174.162 2.8728 0.0861598 8 

double baseK=8.0;

	// demand
	for (j=0; j<n; j++)
	{	d[j]=ran.IRandom(1,20);
	}	

	// cost parameters
	for (i=0; i<m; i++)
	{	for (j=0; j<n; j++)
		{	
			// setup cost
			//K[i][j]=2.0;
			if (i==L)
				K[i][j]=baseK;			
			//else if (i<L)
			//	K[i][j]=0.0;			
			else
			{	//K[i][j]=1+2*ran.Random();
				K[i][j]=round(2*baseK*ran.Random(),2);
			}
			//K[1][1]=100.0;
			//K[2][1]=100.0;

			// production cost
			if (i<=L)
			{	p[i][j]=1.0;
				//p[i][j]=0.0;
			}
			else
			{	//p[i][j]=round(ran.Random(),2);
				p[i][j]=1.0;
			}
			
			// holding cost
			//h[i][j]=1.0;
			//h[i][j]=1.0*(i+1)/m;
			//h[i][j]=1.0*pow(i+1,2.0)/pow(m,2.0);
			//h[i][j]=0.01+1.0*pow(i,2.0)/pow(m-1,2.0);
			if (i<=L)
				h[i][j]=0.01*(i+1);
			else
				h[i][j]=1.0*(i-L)/(m-L-1);
		}
	}

	// bottleneck cap
	U=10.0;